<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dachi's Blog 达迟的博客</title>
    <description>Dachi's Personal Blog.</description>
    <link>http://dachicj.com/</link>
    <atom:link href="http://dachicj.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 11 Mar 2018 16:13:17 +0800</pubDate>
    <lastBuildDate>Sun, 11 Mar 2018 16:13:17 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>2018-03-11 [翻译]前端工程师手册2018回顾&amp;展望部分</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;学习材料&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;本周看到了这个前端工程师手册2018，觉得2017年回顾和2018年展望很有意思，稍稍翻译一下，个中观点是作者的主观意见，请各位读者加以甄别参考。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1.&lt;a href=&quot;https://frontendmasters.com/books/front-end-handbook/2018/&quot;&gt;前端工程师手册2018/Front-End Developer Handbook 2018&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;part-1-recap-of-front-end-development-in-2017-2017&quot;&gt;Part 1 Recap of Front-end Development in 2017 回顾2017&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;=&amp;gt; HTML 5.2 版本完成&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 2017年从市场的接纳程度和流行程度来说是Vue.js很好的一年&lt;/li&gt;
  &lt;li&gt;=&amp;gt; HTML &amp;amp; CSS开发者和Web App开发者的分别已经很明显&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 前端工程师开发Web应用的技术在不断的变好和变坏(意指工具越来越多，生态越来越复杂)&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 有更多的工具/框架和主流开发框架竞争[React,Vue,Angular],其中包括[Moon, Marko, Hyperapp, Quasar Framework, POI, frint, BunnyJS, jsblocks, Sapper, Stimulus, Choo]&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 过去的在线js编辑器[jsbin,jsfiddle]进化成[StackBliz,codeSandbox]这样的工具，使得在线分享Web App变得十分简单&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 有越来越多的框架致敬或者采纳了React的理念[preact, inferno, nerv, dva, and rax.] Rax是阿里开发的一套在Web/Weex上跨平台的兼容React语法的开发框架&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 语法速查集成网站&lt;a href=&quot;https://devhints.io/&quot;&gt;devhints.io.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;=&amp;gt; “正确”搭建一个项目的方式有的时候因人而异，Create-React-App(facebook官方出品的React项目搭建工具)具有可以移除消除项目配置的功能&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 大多数开发者会一起使用好的code editor, eslint以及prettier使得编程更快、更简易、更愉悦。&lt;/li&gt;
  &lt;li&gt;=&amp;gt; CSS Flexbox和Grid都获得了浏览器的支持，开发者现在开始关注这两个布局方法&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 终于有了&lt;a href=&quot;https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md&quot;&gt;无界面chrome&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 有更好的&lt;a href=&quot;https://shoelace.style/&quot;&gt;CSS库&lt;/a&gt;来处理一些CSS的新特性&lt;/li&gt;
  &lt;li&gt;=&amp;gt; CSS有一些&lt;a href=&quot;http://ryanogles.by/css/javascript/2017/05/25/the-state-of-css.html&quot;&gt;巨大的变化&lt;/a&gt;在发生&lt;/li&gt;
  &lt;li&gt;=&amp;gt; JavaScript的&lt;a href=&quot;https://sdras.github.io/array-explorer/&quot;&gt;数组&lt;/a&gt;和对象检测工具出现了&lt;/li&gt;
  &lt;li&gt;=&amp;gt; &lt;a href=&quot;https://brave.com/&quot;&gt;Brave&lt;/a&gt;浏览器是最安全的浏览器&lt;/li&gt;
  &lt;li&gt;=&amp;gt; PhantomJS不再维护，headless chrome和puppeteer登场&lt;/li&gt;
  &lt;li&gt;=&amp;gt; Prettier逐渐变为开发中必备工具&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 很多开发者开始对代码进行静态检查，比如TypeScript或者是Flow, 但是这会带来更多的复杂度，目前这还是主观趋势。&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 静态网站开发工具也逐渐进入开发者的视野&lt;/li&gt;
  &lt;li&gt;=&amp;gt; Web Components依然不火，以后也未必能火&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 许多人现在在开发时开始转向CSS In JS&lt;/li&gt;
  &lt;li&gt;=&amp;gt; Yarn的一个价值是给npm带来了竞争感&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 许多人开始意识到组件架构和原子化设计之间的关系&lt;/li&gt;
  &lt;li&gt;=&amp;gt; ES模块将变为浏览器实现的一部分，或者得使用webpack这样的工具来打包&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 一首凉凉送给MVC框架&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 独立设计React组件的工具出现了[Bluekit, Storybook, React Styleguidist, bit.]&lt;/li&gt;
  &lt;li&gt;=&amp;gt; HTML preloading功能出现了&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 所有主流浏览器现在都支持WebAssembly&lt;/li&gt;
  &lt;li&gt;=&amp;gt; Webpack统治了市场，parcel这样的竞争者出现了&lt;/li&gt;
  &lt;li&gt;=&amp;gt; React 16(Fiber)发布了&lt;/li&gt;
  &lt;li&gt;=&amp;gt; React目前是构造UI最流行的框架&lt;/li&gt;
  &lt;li&gt;=&amp;gt; React更改了开源协议[React的新闻还真是多]&lt;/li&gt;
  &lt;li&gt;=&amp;gt; GraphQL在17年逐渐变得火爆&lt;/li&gt;
  &lt;li&gt;=&amp;gt; Facebook继续在开发领域添砖加瓦(prepack.io,提升js性能的打包工具)&lt;/li&gt;
  &lt;li&gt;=&amp;gt; ECMA-262 editon 8 （JavaScript标准)发布了&lt;/li&gt;
  &lt;li&gt;=&amp;gt; React Router终于稳(chong)定(xie)了&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 所有主流浏览器都支持ES2015(ES6)了&lt;/li&gt;
  &lt;li&gt;=&amp;gt; Async JS函数开始受到越来越多的关注，因为浏览器支持了&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 移动开发依然很难，有些人开始推崇PWA&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;part-2-in-2018-expect-2018&quot;&gt;Part 2 In 2018 expect… 展望2018年&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;=&amp;gt; React在接下来的几年里都会持续火&lt;/li&gt;
  &lt;li&gt;=&amp;gt; GraphQL也许会替代很多REST API&lt;/li&gt;
  &lt;li&gt;=&amp;gt; Web应用会变得更像原生应用，具备线下模式&lt;/li&gt;
  &lt;li&gt;=&amp;gt; HTML5.3 is coming&lt;/li&gt;
  &lt;li&gt;=&amp;gt; &lt;a href=&quot;https://medium.com/@ericsimons/introducing-turbo-5x-faster-than-yarn-npm-and-runs-natively-in-browser-cc2c39715403&quot;&gt;turbo&lt;/a&gt;是一个值得关注的npm客户端，非常快&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 学会使用CSS transform 3d, CSS transition, CSS flexbox, CSS filters ,CSS grid&lt;/li&gt;
  &lt;li&gt;=&amp;gt; JavaScript的使用场景将会越来越多&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 离Web Assembly大行其道还有一段距离，还需要好的工具&lt;/li&gt;
  &lt;li&gt;=&amp;gt; PostCSS, CSSnext, CSS in JS将会取代css预处理器&lt;/li&gt;
  &lt;li&gt;=&amp;gt; SPA + 服务器端渲染的架构正在渐渐发展(pjax: pushState + ajax)&lt;/li&gt;
  &lt;li&gt;=&amp;gt; PWA也许会火，也许(永远)不会，起码不是以目前的形式&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 建立在人工智能和神经网络的聊天机器人也许会促进线上沟通的，谁也不知道会走向何方&lt;/li&gt;
  &lt;li&gt;=&amp;gt; Vue也许会超越Angular&lt;/li&gt;
  &lt;li&gt;=&amp;gt; AR/AV,AI会持续发展(js不也有深度学习框架了么～)&lt;/li&gt;
  &lt;li&gt;=&amp;gt; JavaScript Symbol和Generator估计不会进入程序员视野&lt;/li&gt;
  &lt;li&gt;=&amp;gt; Webpack4将会因为竞争者的出现变得更好&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 业界将会不停寻找树形UI组件的理想CSS解决方案&lt;/li&gt;
  &lt;li&gt;=&amp;gt; 状态管理这一块逐渐稳定下来，mobx也许会大放异彩&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注：根据作者的观点，前端界将在接下来的日子里继续出现新的变化，但同时一些领域开始逐渐稳定，比如MVVM框架[React,Vue,Angular], 围绕React生态出现了一些辅助工具和继承者，另一方面CSS将出现一些变化[CSS In JS, CSSnext], PWA可能不会太火但值得关注，无论如何随时随地保持学习，与大家共勉。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 11 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://dachicj.com/2018/03/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</link>
        <guid isPermaLink="true">http://dachicj.com/2018/03/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</guid>
        
        
      </item>
    
      <item>
        <title>2017-11-05 技术学习笔记</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;学习材料&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/&quot;&gt;https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/&quot;&gt;https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/&lt;/a&gt;
本周继续承接&lt;a href=&quot;http://dachicj.com/2017/10/22/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html&quot;&gt;上一篇文章&lt;/a&gt;读的新一代火狐浏览器内核CSS引擎介绍文章,&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;part-1-quantum-css&quot;&gt;Part 1 Quantum CSS&lt;/h2&gt;

&lt;h3 id=&quot;quantum-csscss&quot;&gt;Quantum CSS对CSS渲染的优化&lt;/h3&gt;
&lt;p&gt;在用户浏览网页的时候，CSS渲染无时不刻的发生，首次加载，用户的任何操作，都会导致重新CSS的重新渲染。Quantum CSS采用了混合多种策略对CSS渲染进行优化。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;平行计算&lt;/h3&gt;
&lt;p&gt;随着多核CPU的普及，那么将样式计算分摊给不同的CPU内核似乎是个非常合理的思路，但是将不同的样式分拆给不同的CPU核其实没那么简单，因为DOM树有可能存在两边节点数目差距较大的情况，这样计算工作的分配就会不那么公平，为了解决这个问题，Quantum CSS将不同的DOM节点分配到不同的队列里，每一个CPU核在计算完分配给自己的计算任务后，会去其他的队列查看是否还有没完成的计算任务，这样甚至不需要提前计算如何分配样式的计算任务。&lt;/p&gt;

&lt;p&gt;但是由于平行计算和CSS样式计算的复杂性，这种工程设计很容易引入各种Bug以及一种叫&lt;a href=&quot;https://hacks.mozilla.org/2017/06/avoiding-race-conditions-in-sharedarraybuffers-with-atomics/#data-race&quot;&gt;Data races&lt;/a&gt;的问题，火狐的工程师们利用了Rust语言的特性避免了这类问题的发生。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;用规则树加速样式再计算&lt;/h3&gt;
&lt;p&gt;由于困这段没太看懂, 下次再研究一下…&lt;/p&gt;

&lt;h3 id=&quot;style-sharing-cache&quot;&gt;用样式共享缓存(Style sharing cache)加速首次加载样式计算&lt;/h3&gt;
&lt;p&gt;一个网页可能有成千上百DOM节点，并且其中大多数节点的部分样式都是一致的，没有优化的CSS引擎可能要重复无数次的相同计算，如果将相同元素的相同样式指向同一个样式对象，无疑可以为CSS引擎节省很多的无效开销，而Safari和Chrome浏览器使用了样式共享缓存。&lt;/p&gt;

&lt;p&gt;样式共享缓存在计算节点的样式时，会检查几点来确认是否某些元素可以共享样式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;两个节点是否有相同的id和class&lt;/li&gt;
  &lt;li&gt;两个节点的母节点是否指向相同的样式对象，如果是的话，这些节点继承的属性也应指向相同的地方。&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用样式共享缓存无疑可以节省内存开销并且提高计算的速度。&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://dachicj.com/2017/11/05/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</link>
        <guid isPermaLink="true">http://dachicj.com/2017/11/05/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</guid>
        
        
      </item>
    
      <item>
        <title>2017-10-22 技术学习笔记</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;学习材料&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/&quot;&gt;https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/&quot;&gt;https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这周暂时放下CSS In Depth的学习，因为看到了来自Firefox浏览器工程师团队的两篇文章，觉得真的很不错，即介绍了火狐下一代浏览器内核的实现，又介绍了浏览器的工作流程，建议前端同学都可以看看（虽然是英文的，但是有很多图片，有助于阅读理解),可以加深对浏览器机制的理解。&lt;/p&gt;

&lt;h2 id=&quot;part-1-quantum-css&quot;&gt;Part 1 Quantum CSS&lt;/h2&gt;

&lt;h3 id=&quot;quantum-css&quot;&gt;Quantum CSS简介&lt;/h3&gt;
&lt;p&gt;Quantum，也就是下一代火狐浏览器的内核，大致由Quantum DOM, Quantum CSS, Quantom Compositor, Quantum Render几个部分组成，其中，Quantum CSS和Quantum Render是解析、渲染网页最为核心的部分，学习材料里的第一个首先介绍了Quantum CSS， 作者首先介绍了Quantum CSS快速的几个原因&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Parallel computing: 平行计算, Quantum CSS新技术&lt;/li&gt;
  &lt;li&gt;Rule tree: Firefox原有技术，具体内容尚不明&lt;/li&gt;
  &lt;li&gt;Style sharing cache: 来自Chrome和Safari,估计是来自WebKit的技术。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;css&quot;&gt;CSS引擎的职责&lt;/h3&gt;
&lt;p&gt;CSS引擎是浏览器渲染引擎的一部分，渲染引擎的工作就是把前端工程师辛辛苦苦写好的HTML &amp;amp; CSS转化为屏幕上的每一个像素,那么这个转化的过程可以大致分为五个步骤。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;解析：将HTML解析为DOM(Document Object Model)，这是一个网页在内存中的虚拟对象，在React等技术出现前，以前的前端程序员都要依靠操作DOM来动态的改变网页的结构,这一步决定网页里应该有什么元素（标题，文字，按钮，等等等等)&lt;/li&gt;
  &lt;li&gt;样式: 计算出每个DOM中元素的样式应该是什么样的，每一个元素应该长成什么样子。&lt;/li&gt;
  &lt;li&gt;布局: 前端程序员肯定熟悉Box模型，在这一个步骤里，渲染引擎将计算出每一个元素自身的盒模型(Box)的尺寸和位置。&lt;/li&gt;
  &lt;li&gt;绘制：绘制各元素的Box, 绘制的过程可以发生在很多图层，这样使得修改一个图层而不影响其他图层变的可能。（在渲染过程中图层代表什么目前笔者尚不明确。)&lt;/li&gt;
  &lt;li&gt;组合：对各个图层应用某些特定属性(比如CSS transforms)，将所有图层组合在一起并呈现到显示器上。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;css-1&quot;&gt;CSS引擎具体工作流程&lt;/h3&gt;
&lt;p&gt;当开始计算样式前，CSS引擎已经拥有了&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;DOM树&lt;/li&gt;
  &lt;li&gt;样式规则列表
CSS引擎会遍历每一个DOM节点，计算出该节点的样式，计算出这个节点的&lt;strong&gt;每一个&lt;/strong&gt;CSS属性的值，即使stylesheet没有设置这个属性。为了完成这项工作，CSS引擎需要&lt;/li&gt;
  &lt;li&gt;selector matching: 寻找那些设置了值的样式属性&lt;/li&gt;
  &lt;li&gt;cascade: 找不到设定的属性，就寻找继承或者默认的属性, 这部分的相关内容可以在上上篇博文里找到:)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;selector-matching&quot;&gt;Selector matching&lt;/h3&gt;
&lt;p&gt;CSS引擎会对照样式表，将对应DOM节点的样式加载到一个列表上，由于一个CSS属性可以match多个值，所以需要根据优先级规则来决定某个id/class/tag的样式应该应用哪一个值,这个规则的设定也可以参考CSS In Depth第一章的学习笔记。&lt;/p&gt;

&lt;h3 id=&quot;cascade&quot;&gt;Cascade&lt;/h3&gt;
&lt;p&gt;当完成了selector matching后，某个id/class/tag对应的DOM node的样式仍然存在空缺，这时候需要寻找该属性的继承或者默认值，这样每一个DOM node的全部CSS属性就完成了计算。&lt;/p&gt;

&lt;h3 id=&quot;style-struct-sharing&quot;&gt;Style struct sharing&lt;/h3&gt;
&lt;p&gt;上面的文字存在一定误导成分啊哈，CSS总共有几百个属性，如果都要计算的话那估计很快就内存不足了，CSS引擎讲将这些值存储到一个叫style struct的对象里，这样DOM节点的样式可能指针指到这些对象上，拥有相似属性的DOM节点（比如兄弟节点）可以将样式都指到相同的style struct上；很多时候父节点会让很多子节点继承属性，他们之间也可以共享style struct。&lt;/p&gt;

&lt;h3 id=&quot;quantum-css-1&quot;&gt;Quantum CSS是如何优化上述过程的&lt;/h3&gt;
&lt;p&gt;我知道写到快干货的地方停了不太合适，不过后面篇幅有点长，等下周继续学习更新啊哈哈哈哈…Zzzzzz…&lt;/p&gt;

</description>
        <pubDate>Sun, 22 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://dachicj.com/2017/10/22/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</link>
        <guid isPermaLink="true">http://dachicj.com/2017/10/22/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</guid>
        
        
      </item>
    
      <item>
        <title>2017-10-15 前端学习笔记</title>
        <description>&lt;h3 id=&quot;css-in-depth-chapter-01--02&quot;&gt;学习材料： CSS In Depth Chapter 01 &amp;amp; 02&lt;/h3&gt;

&lt;h2 id=&quot;chapter-01&quot;&gt;Chapter 01&lt;/h2&gt;

&lt;h3 id=&quot;shorthand&quot;&gt;1.4 Shorthand&lt;/h3&gt;

&lt;h4 id=&quot;font--fontinitial-value-&quot;&gt;font:  会将font相关的属性都设置为initial value(默认值), 比如&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.title {
  font: 32px Helvetica, Arial, sans-serif; # 会将font-weight设为normal
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;padding-paddingtop-right-bottom-left-paddingtoppadding-leftpaddingrightpadding&quot;&gt;padding: 设置padding的顺序分别为top, right, bottom, left（顺时针), 如果底部的padding缺失，会使用top的padding, 如果left的padding缺失会使用right的padding.&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.example {
	padding: 1px 1px 1px 1px; # 完整
	padding: 1px 2px 1px; # 等于1px 2px 1px 2px;
	padding: 1px 2px; # 等于1px 2px 1px 2px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;background-position-box-shadow-text-shadow--horizontalvertical&quot;&gt;background-position, box-shadow, text-shadow: 这几个属性只有两个方向, 横向(horizontal)和纵向(vertical)&lt;/h4&gt;

&lt;h2 id=&quot;chapter-02-working-with-relative-units&quot;&gt;Chapter 02 Working with relative units&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;第二章主要讲解&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用相对单位时的种种变化&lt;/li&gt;
  &lt;li&gt;理解ems和rems,并且不被整疯&lt;/li&gt;
  &lt;li&gt;使用viewport相关单位&lt;/li&gt;
  &lt;li&gt;CSS变量&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;绝对单位和相对单位&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;绝对单位:比如5px就是绝对单位&lt;/li&gt;
  &lt;li&gt;相对单位: em和rem是相对单位，在不同的设备上含义不同&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;powerful&quot;&gt;2.1 相对单位很大力(Powerful)&lt;/h3&gt;
&lt;p&gt;早起的程序开发，程序员面对的都是一成不变的屏幕尺寸，比如一个程序的窗口就是确切的400*300像素，Web时代时，情况有所变化，因为浏览器的窗口会变化，每一次浏览器尺寸的变化，都需要重新计算和引用CSS值才能重新渲染页面，在很长一段时间内，网页设计师都追求”完美像素”风格的设计，他们会创建一个800像素左右宽的容器，然后在里面搞事情，这种设计有点像以前的桌面开发。&lt;/p&gt;

&lt;p&gt;但是随着显示器分辨率的提高（800-&amp;gt;1024-&amp;gt;1280)，这种Pixel-Perfect的开发方式不灵了，然后没几年智能手机又来了，所以设计师需要停止“所有用户都能获得完全一致的使用体验”这种幻觉，这种固定像素尺寸的设计也将被舍弃了。顺应时代的潮流CSS也提出了新的抽象，那就是相对单位。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;CSS的各种单位，除了最广为人知的pixel,CSS还有mm(millimeter), cm(entimeter),in(inch),pt(point)，pc(pica) (*笔者注:我从来都用过这些), 这些单位的转换关系是1inch = 25.4mm =2.54cm =6pica = 72pt =96px&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 15 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://dachicj.com/2017/10/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</link>
        <guid isPermaLink="true">http://dachicj.com/2017/10/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</guid>
        
        
      </item>
    
      <item>
        <title>2017-09-24 本周前端学习笔记</title>
        <description>&lt;h3 id=&quot;css-in-depth-chapter-01&quot;&gt;学习材料： CSS In Depth Chapter 01&lt;/h3&gt;

&lt;p&gt;本周继续学习CSS In Depth第一章的剩余部分&lt;/p&gt;

&lt;h3 id=&quot;inheritance&quot;&gt;1.2 Inheritance&lt;/h3&gt;
&lt;p&gt; 
当一个元素没有设置的样式，它将从它的母元素获得样式。
注意inheritance和此前讨论的cascade概念并不相同，也并不是
所有的样式都会被继承，被继承的属性包括:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;字体类属性: color, font, font-family, font-size, font-weight, font-variant等&lt;/li&gt;
  &lt;li&gt;列表类属性: list-style, list-style-type, list-style-position,list-style-image&lt;/li&gt;
  &lt;li&gt;表格边框属性: border-collapse, border-spacing&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;inherit--initial&quot;&gt;1.3 Inherit &amp;amp; Initial&lt;/h3&gt;
&lt;p&gt;有两种特殊的CSS值可以应用到任何CSS属性上, inherit和initial.
 &lt;/p&gt;
&lt;h4 id=&quot;inherit&quot;&gt;inherit&lt;/h4&gt;
&lt;p&gt;有时你希望某个元素可以继承母元素的样式而不是使用默认定义的样式，那就是
使用inherit的时候.
 &lt;/p&gt;
&lt;h4 id=&quot;initial&quot;&gt;initial&lt;/h4&gt;
&lt;p&gt;有时候你想取消某些元素的样式，你可以使用initial这个值，使得某个属性被设定为默认的属性，比如&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;footer {
 color: initial;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;footer {
 color: black;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;有时initial值对于某些属性并不起作用，是因为这些属性没有默认值，比如border-width或者padding, 但是赋予他们initial的值完全合法。&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://dachicj.com/2017/09/24/%E6%9C%AC%E5%91%A8%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</link>
        <guid isPermaLink="true">http://dachicj.com/2017/09/24/%E6%9C%AC%E5%91%A8%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</guid>
        
        
      </item>
    
      <item>
        <title>2017-09-17 本周前端学习笔记</title>
        <description>&lt;h3 id=&quot;css-in-depth-chapter-01&quot;&gt;学习材料： CSS In Depth Chapter 01&lt;/h3&gt;

&lt;p&gt;因为一直想要巩固CSS基础和对于CSS的理解，碰巧找到了一本不错的书&lt;a href=&quot;https://www.manning.com/books/css-in-depth&quot;&gt;CSS In Depth&lt;/a&gt;, 本周阅读了其免费的第一章
 &lt;/p&gt;
&lt;h3 id=&quot;chatper-01-cascade-specificity-inheritance&quot;&gt;Chatper 01 Cascade(瀑布流), Specificity(特选性）, Inheritance(继承)&lt;/h3&gt;
&lt;p&gt;我一直都很好奇CSS的Cascade（字面意义是瀑布)是什么意思, 为什么要用瀑布来形容样式? 在看过这一章后，我对Cascade的理解就是，同一个元素可以应用多种样式(甚至是冲突的样式)，而CSS要根据几个原则来解决冲突使得某个元素的样式可以从最宽泛的设置一直滑落到最适合它的范围(嗯，我知道这么强行解释有些尴尬不过CSS的创始人是&lt;a href=&quot;http://www.wiumlie.no/2006/phd/#cascading&quot;&gt;这么说&lt;/a&gt;的所以你们就忍了吧)&lt;/p&gt;

&lt;p&gt;好的，那么我们来看看当一个元素被应用了多种样式后应该如何解决样式的合并和冲突。&lt;/p&gt;

&lt;h3 id=&quot;css&quot;&gt;0.如何解决CSS的冲突&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;来源： 样式从何而来 (higher priority origin)&lt;/li&gt;
  &lt;li&gt;范围： 是否有inline样式 (应用inline样式)&lt;/li&gt;
  &lt;li&gt;选择器：选择元素的精细程度（higer specificity)&lt;/li&gt;
  &lt;li&gt;顺序： 样式定义顺序 (later in source order)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;origin&quot;&gt;1.origin&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;用户设置的!important样式&lt;/li&gt;
  &lt;li&gt;用户设置的样式&lt;/li&gt;
  &lt;li&gt;浏览器默认样式&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;inline-scope&quot;&gt;2.inline scope&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;a style='color:red;'&amp;gt;Link&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;注意,加了important的inline style无人能压制&lt;/p&gt;

&lt;h3 id=&quot;selector-specificity&quot;&gt;3.selector specificity&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;规则: 更多的ids &amp;gt; 更多的classes &amp;gt; 更多的tags&lt;/li&gt;
  &lt;li&gt;每一个元素的选择器都可以写成这样[id数量，class数量，tags数量]&lt;/li&gt;
  &lt;li&gt;当你给元素一个id时，如何覆盖这个id的样式:
    &lt;ul&gt;
      &lt;li&gt;新样式加入important&lt;/li&gt;
      &lt;li&gt;新样式加上id和class&lt;/li&gt;
      &lt;li&gt;原样式的id降级为class&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section&quot;&gt;4.顺序这个就不用说了吧,后来者居上&lt;/h3&gt;

&lt;h3 id=&quot;section-1&quot;&gt;5.一点来自作者的建议&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;不要用id, 很难覆盖&lt;/li&gt;
  &lt;li&gt;不要用important, 很难覆盖&lt;/li&gt;
  &lt;li&gt;如果你在写一个库给别人用的话，不要用inline style, 否则用你库的人根本没法覆盖这个样式
 
 &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 17 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://dachicj.com/2017/09/17/%E6%9C%AC%E5%91%A8%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</link>
        <guid isPermaLink="true">http://dachicj.com/2017/09/17/%E6%9C%AC%E5%91%A8%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</guid>
        
        
      </item>
    
      <item>
        <title>本周JS学习笔记</title>
        <description>&lt;h3 id=&quot;yon-dont-know-jstype--grammer-chapter-01&quot;&gt;学习材料： Yon don’t know JS(Type &amp;amp; Grammer) Chapter 01&lt;/h3&gt;

&lt;h2 id=&quot;section&quot;&gt;什么是类型&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;An intrinsic, built-in set of characteristics that uniquely identifies the behavior of a particular value and distinguishes it from other values, both to the engine and to the developer.(对JS引擎和开发者而言的一套拥有内置独特特性和行为的特殊值，并与其他值相区别)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;关键字&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;对JS引擎和开发者：引擎和开发者在处理不同类型时都需要不同的方式。&lt;/li&gt;
  &lt;li&gt;独特特性和行为: 每种类型的值有自己的特性和行为。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;js&quot;&gt;JS内置类型&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;null&lt;/li&gt;
  &lt;li&gt;undefined&lt;/li&gt;
  &lt;li&gt;boolean&lt;/li&gt;
  &lt;li&gt;number&lt;/li&gt;
  &lt;li&gt;string&lt;/li&gt;
  &lt;li&gt;object&lt;/li&gt;
  &lt;li&gt;symbol(ES6新增)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//try this&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;object&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//会显示true,但是是不正确的，这个是历史遗留问题&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;function&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//true, 但是function并不是单独的类型，它是callable object, object的一种子类型&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;更安全的检查变量方式&lt;/h2&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//假设你的代码通过某个全局变量DEBUG来检查运行环境&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;DEBUG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//会throw ReferenceError&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;DEBUG&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'undefined'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//更安全&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//使用typeof来查看某功能是否存在&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doSomethingCool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;helper&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
		&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;FeatureXYZ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;undefined&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;FeatureXYZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

		&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;helper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;values-as-types&quot;&gt;Values as Types&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;在JS中，变量不拥有类型，但是values(值)拥有类型，变量可以绑定任意类型&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;coercion-&quot;&gt;Coercion 类型转换&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;类型转换有时是显式的，可读的，有的时候会在不经意间发生。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 10 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://dachicj.com/2017/09/10/%E6%9C%AC%E5%91%A8JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</link>
        <guid isPermaLink="true">http://dachicj.com/2017/09/10/%E6%9C%AC%E5%91%A8JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</guid>
        
        
      </item>
    
      <item>
        <title>学习Webpack</title>
        <description>&lt;h3&gt;Webpack Config&lt;/h3&gt;
&lt;ol&gt;
    &lt;li&gt;入口文件&lt;/li&gt;
    &lt;li&gt;目的地址&lt;/li&gt;
    &lt;li&gt;loader: 用于转换各种文件&lt;/li&gt;
    &lt;li&gt;plugin: 提供各种插件功能&lt;/li&gt;
    &lt;li&gt;externals: 外部设定&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 27 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://dachicj.com/2016/11/27/Study-Webpack.html</link>
        <guid isPermaLink="true">http://dachicj.com/2016/11/27/Study-Webpack.html</guid>
        
        
      </item>
    
      <item>
        <title>学习Chromium源代码</title>
        <description>&lt;p&gt;
    Chrome是谷歌自家出品的浏览器，Chromium则是Chrome背后的引擎，作为一名想(bu)要(de)学(bu)习(xue)浏览器知识的码农,
    Chromium是非常具有研究价值的对象，不过这个Project极其庞大，我们只能从一些小的方面入手，做一些微小的学习工作。
&lt;/p&gt;

&lt;p&gt;
    在进行具体的学习之前，我们不妨从Chromium的代码结构入手，高屋建瓴地总览一下Chorimium, 这份
    &lt;a href=&quot;https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code&quot;&gt;官方文档&lt;/a&gt;
    是一个很好的学习材料。
&lt;/p&gt;

&lt;p&gt;
    Chromium大致可以分为三个部分:
    &lt;ol&gt;
        &lt;li&gt;浏览器,负责所有的UI以及I/O。&lt;/li&gt;
        &lt;li&gt;渲染器,在一般情况下是由浏览器驱动的基于tab的子程序。&lt;/li&gt;
        &lt;li&gt;Webkit,渲染器嵌入了Webkit来进行布局和渲染。&lt;/li&gt;
    &lt;/ol&gt;
&lt;/p&gt;

&lt;p&gt;Chromium架构图:&lt;/p&gt;
&lt;img src=&quot;../../../img/chromium_arch.png&quot;&gt;

&lt;p&gt;
    Chromium由许多个子项目组成，这些项目有:
    &lt;ol&gt;
    &lt;li&gt;android_webview&lt;/li&gt;
    &lt;li&gt;apps&lt;/li&gt;
    &lt;li&gt;base&lt;/li&gt;
    &lt;li&gt;breakpad&lt;/li&gt;
    &lt;li&gt;build&lt;/li&gt;
    &lt;li&gt;cc&lt;/li&gt;
    &lt;li&gt;chrome: Chromium浏览器&lt;/li&gt;
    &lt;li&gt;chrome/test/data&lt;/li&gt;
    &lt;li&gt;components&lt;/li&gt;
    &lt;li&gt;content: 一个多进程沙箱浏览器的核心代码&lt;/li&gt;
    &lt;li&gt;device&lt;/li&gt;
    &lt;li&gt;net&lt;/li&gt;
    &lt;li&gt;sandbox&lt;/li&gt;
    &lt;li&gt;skia&lt;/li&gt;
    &lt;li&gt;sql&lt;/li&gt;
    &lt;li&gt;testing&lt;/li&gt;
    &lt;li&gt;third_party&lt;/li&gt;
    &lt;li&gt;tools&lt;/li&gt;
    &lt;li&gt;ui/gfx&lt;/li&gt;
    &lt;li&gt;ui/views: 一个UI开发的简单框架&lt;/li&gt;
    &lt;li&gt;url: Google的开源URL parsing库&lt;/li&gt;
    &lt;li&gt;v8: V8 JavaScript库&lt;/li&gt;
    &lt;li&gt;webkit: webkit相关代码&lt;/li&gt;
    &lt;/ol&gt;
&lt;/p&gt;

&lt;p&gt;
    缘于Chromium代码架构宏大，绝非一朝一夕能够理解、学习之项目，我将在未来持续地学习这个项目，加深我对浏览器的理解。
&lt;/p&gt;

&lt;p&gt;
    &lt;a href=&quot;https://chromium.googlesource.com/chromium/src.git/+/master&quot;&gt;源码地址&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
    &lt;a href=&quot;https://www.chromium.org/Home&quot;&gt;延伸阅读&lt;/a&gt;
&lt;/p&gt;

</description>
        <pubDate>Wed, 19 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://dachicj.com/2016/10/19/Chromium-Code-Structure.html</link>
        <guid isPermaLink="true">http://dachicj.com/2016/10/19/Chromium-Code-Structure.html</guid>
        
        
      </item>
    
      <item>
        <title>学习MySQL体系结构</title>
        <description>&lt;h2&gt;MySQL技术内幕：InnoDB存储引擎大纲&lt;/h2&gt;
&lt;ol&gt;
    &lt;li&gt;&lt;details&gt;&lt;summary&gt;MySQL体系结构&lt;/summary&gt;&lt;/details&gt;&lt;/li&gt;
    &lt;li&gt;&lt;details&gt;&lt;summary&gt;InnoDB存储引擎&lt;/summary&gt;&lt;/details&gt;&lt;/li&gt;
    &lt;li&gt;&lt;details&gt;&lt;summary&gt;文件&lt;/summary&gt;&lt;/details&gt;&lt;/li&gt;
    &lt;li&gt;&lt;details&gt;&lt;summary&gt;表&lt;/summary&gt;&lt;/details&gt;&lt;/li&gt;
    &lt;li&gt;&lt;details&gt;&lt;summary&gt;索引与算法&lt;/summary&gt;&lt;/details&gt;&lt;/li&gt;
    &lt;li&gt;&lt;details&gt;&lt;summary&gt;锁&lt;/summary&gt;&lt;/details&gt;&lt;/li&gt;
    &lt;li&gt;&lt;details&gt;&lt;summary&gt;事务&lt;/summary&gt;&lt;/details&gt;&lt;/li&gt;
    &lt;li&gt;&lt;details&gt;&lt;summary&gt;备份与恢复&lt;/summary&gt;&lt;/details&gt;&lt;/li&gt;
    &lt;li&gt;&lt;details&gt;&lt;summary&gt;性能调优&lt;/summary&gt;&lt;/details&gt;&lt;/li&gt;
    &lt;li&gt;&lt;details&gt;&lt;summary&gt;InnoDB存储引擎源代码的编译和调试&lt;/summary&gt;&lt;/details&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;1.MySQL体系结构&lt;/h3&gt;
&lt;p&gt;数据库(Database)是文件的集合&lt;/p&gt;
&lt;p&gt;示例(Instance)是运行在内存中的示例&lt;/p&gt;
&lt;p&gt;
MySQL组成部分
    &lt;ul&gt;
      &lt;li&gt;连接池组件&lt;/li&gt;
      &lt;li&gt;管理服务和工具组件&lt;/li&gt;
      &lt;li&gt;SQL接口组件&lt;/li&gt;
      &lt;li&gt;查询分析器组件&lt;/li&gt;
      &lt;li&gt;优化器组件&lt;/li&gt;
      &lt;li&gt;缓冲(Cache)组件&lt;/li&gt;
      &lt;li&gt;插件式存储引擎&lt;/li&gt;
      &lt;li&gt;物理文件&lt;/li&gt;
    &lt;/ul&gt;
&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://dachicj.com/2016/10/12/MySQL_Engine.html</link>
        <guid isPermaLink="true">http://dachicj.com/2016/10/12/MySQL_Engine.html</guid>
        
        
      </item>
    
  </channel>
</rss>
